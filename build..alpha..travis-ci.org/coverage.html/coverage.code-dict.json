{"/home/travis/build/npmtest/node-npmtest-sharp/test.js":"/* istanbul instrument in package npmtest_sharp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sharp/lib.npmtest_sharp.js":"/* istanbul instrument in package npmtest_sharp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_sharp = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_sharp = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-sharp/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-sharp && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_sharp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_sharp\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_sharp.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_sharp.rollup.js'] =\n            local.assetsDict['/assets.npmtest_sharp.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_sharp.__dirname +\n                    '/lib.npmtest_sharp.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sharp/sharp/lib/index.js":"'use strict';\n\nconst Sharp = require('./constructor');\n[\n  'input',\n  'resize',\n  'composite',\n  'operation',\n  'colour',\n  'channel',\n  'output',\n  'utility'\n].forEach(function (decorator) {\n  require('./' + decorator)(Sharp);\n});\n\nmodule.exports = Sharp;\n","/home/travis/build/npmtest/node-npmtest-sharp/sharp/lib/constructor.js":"'use strict';\n\nconst path = require('path');\nconst util = require('util');\nconst stream = require('stream');\nconst events = require('events');\nconst semver = require('semver');\nconst sharp = require('../build/Release/sharp.node');\n\n// Versioning\nlet versions = {\n  vips: sharp.libvipsVersion()\n};\n(function () {\n  // Does libvips meet minimum requirement?\n  const libvipsVersionMin = require('../package.json').config.libvips;\n  /* istanbul ignore if */\n  if (semver.lt(versions.vips, libvipsVersionMin)) {\n    throw new Error('Found libvips ' + versions.vips + ' but require at least ' + libvipsVersionMin);\n  }\n  // Include versions of dependencies, if present\n  try {\n    versions = require('../vendor/lib/versions.json');\n  } catch (err) {}\n})();\n\n/**\n * @class Sharp\n *\n * Constructor factory to create an instance of `sharp`, to which further methods are chained.\n *\n * JPEG, PNG or WebP format image data can be streamed out from this object.\n * When using Stream based output, derived attributes are available from the `info` event.\n *\n * Implements the [stream.Duplex](http://nodejs.org/api/stream.html#stream_class_stream_duplex) class.\n *\n * @example\n * sharp('input.jpg')\n *   .resize(300, 200)\n *   .toFile('output.jpg', function(err) {\n *     // output.jpg is a 300 pixels wide and 200 pixels high image\n *     // containing a scaled and cropped version of input.jpg\n *   });\n *\n * @example\n * // Read image data from readableStream,\n * // resize to 300 pixels wide,\n * // emit an 'info' event with calculated dimensions\n * // and finally write image data to writableStream\n * var transformer = sharp()\n *   .resize(300)\n *   .on('info', function(info) {\n *     console.log('Image height is ' + info.height);\n *   });\n * readableStream.pipe(transformer).pipe(writableStream);\n *\n * @example\n * // Create a blank 300x200 PNG image of semi-transluent red pixels\n * sharp(null, {\n *   create: {\n *     width: 300,\n *     height: 200,\n *     channels: 4,\n *     background: { r: 255, g: 0, b: 0, alpha: 128 }\n *   }\n * })\n * .png()\n * .toBuffer()\n * .then( ... );\n *\n * @param {(Buffer|String)} [input] - if present, can be\n *  a Buffer containing JPEG, PNG, WebP, GIF, SVG, TIFF or raw pixel image data, or\n *  a String containing the path to an JPEG, PNG, WebP, GIF, SVG or TIFF image file.\n *  JPEG, PNG, WebP, GIF, SVG, TIFF or raw pixel image data can be streamed into the object when null or undefined.\n * @param {Object} [options] - if present, is an Object with optional attributes.\n * @param {Number} [options.density=72] - integral number representing the DPI for vector images.\n * @param {Object} [options.raw] - describes raw pixel input image data. See `raw()` for pixel ordering.\n * @param {Number} [options.raw.width]\n * @param {Number} [options.raw.height]\n * @param {Number} [options.raw.channels] - 1-4\n * @param {Object} [options.create] - describes a new image to be created.\n * @param {Number} [options.create.width]\n * @param {Number} [options.create.height]\n * @param {Number} [options.create.channels] - 3-4\n * @param {String|Object} [options.create.background] - parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nconst Sharp = function (input, options) {\n  if (!(this instanceof Sharp)) {\n    return new Sharp(input, options);\n  }\n  stream.Duplex.call(this);\n  this.options = {\n    // input options\n    sequentialRead: false,\n    limitInputPixels: maximum.pixels,\n    // ICC profiles\n    iccProfilePath: path.join(__dirname, 'icc') + path.sep,\n    // resize options\n    topOffsetPre: -1,\n    leftOffsetPre: -1,\n    widthPre: -1,\n    heightPre: -1,\n    topOffsetPost: -1,\n    leftOffsetPost: -1,\n    widthPost: -1,\n    heightPost: -1,\n    width: -1,\n    height: -1,\n    canvas: 'crop',\n    crop: 0,\n    angle: 0,\n    rotateBeforePreExtract: false,\n    flip: false,\n    flop: false,\n    extendTop: 0,\n    extendBottom: 0,\n    extendLeft: 0,\n    extendRight: 0,\n    withoutEnlargement: false,\n    kernel: 'lanczos3',\n    interpolator: 'bicubic',\n    centreSampling: false,\n    // operations\n    background: [0, 0, 0, 255],\n    flatten: false,\n    negate: false,\n    blurSigma: 0,\n    sharpenSigma: 0,\n    sharpenFlat: 1,\n    sharpenJagged: 2,\n    threshold: 0,\n    thresholdGrayscale: true,\n    trimTolerance: 0,\n    gamma: 0,\n    greyscale: false,\n    normalise: 0,\n    booleanBufferIn: null,\n    booleanFileIn: '',\n    joinChannelIn: [],\n    extractChannel: -1,\n    colourspace: 'srgb',\n    // overlay\n    overlayGravity: 0,\n    overlayXOffset: -1,\n    overlayYOffset: -1,\n    overlayTile: false,\n    overlayCutout: false,\n    // output\n    fileOut: '',\n    formatOut: 'input',\n    streamOut: false,\n    withMetadata: false,\n    withMetadataOrientation: -1,\n    resolveWithObject: false,\n    // output format\n    jpegQuality: 80,\n    jpegProgressive: false,\n    jpegChromaSubsampling: '4:2:0',\n    jpegTrellisQuantisation: false,\n    jpegOvershootDeringing: false,\n    jpegOptimiseScans: false,\n    pngProgressive: false,\n    pngCompressionLevel: 6,\n    pngAdaptiveFiltering: true,\n    webpQuality: 80,\n    webpAlphaQuality: 100,\n    webpLossless: false,\n    webpNearLossless: false,\n    tiffQuality: 80,\n    tiffCompression: 'jpeg',\n    tiffPredictor: 'none',\n    tileSize: 256,\n    tileOverlap: 0,\n    // Function to notify of queue length changes\n    queueListener: function (queueLength) {\n      queue.emit('change', queueLength);\n    }\n  };\n  this.options.input = this._createInputDescriptor(input, options, { allowStream: true });\n  return this;\n};\nutil.inherits(Sharp, stream.Duplex);\n\n/**\n * Pixel limits.\n * @member\n * @private\n */\nconst maximum = {\n  width: 0x3FFF,\n  height: 0x3FFF,\n  pixels: Math.pow(0x3FFF, 2)\n};\nSharp.maximum = maximum;\n\n/**\n * An EventEmitter that emits a `change` event when a task is either:\n * - queued, waiting for _libuv_ to provide a worker thread\n * - complete\n * @member\n * @example\n * sharp.queue.on('change', function(queueLength) {\n *   console.log('Queue contains ' + queueLength + ' task(s)');\n * });\n */\nconst queue = new events.EventEmitter();\nSharp.queue = queue;\n\n/**\n * An Object containing nested boolean values representing the available input and output formats/methods.\n * @example\n * console.log(sharp.format());\n * @returns {Object}\n */\nSharp.format = sharp.format();\n\n/**\n * An Object containing the version numbers of libvips and its dependencies.\n * @member\n * @example\n * console.log(sharp.versions);\n */\nSharp.versions = versions;\n\n/**\n * Export constructor.\n * @private\n */\nmodule.exports = Sharp;\n","/home/travis/build/npmtest/node-npmtest-sharp/sharp/lib/input.js":"'use strict';\n\nconst util = require('util');\nconst color = require('color');\nconst is = require('./is');\nconst sharp = require('../build/Release/sharp.node');\n\n/**\n * Create Object containing input and input-related options.\n * @private\n */\nfunction _createInputDescriptor (input, inputOptions, containerOptions) {\n  const inputDescriptor = {};\n  if (is.string(input)) {\n    // filesystem\n    inputDescriptor.file = input;\n  } else if (is.buffer(input)) {\n    // Buffer\n    inputDescriptor.buffer = input;\n  } else if (!is.defined(input) && is.object(containerOptions) && containerOptions.allowStream) {\n    // Stream\n    inputDescriptor.buffer = [];\n  } else {\n    throw new Error('Unsupported input ' + typeof input);\n  }\n  if (is.object(inputOptions)) {\n    // Density\n    if (is.defined(inputOptions.density)) {\n      if (is.integer(inputOptions.density) && is.inRange(inputOptions.density, 1, 2400)) {\n        inputDescriptor.density = inputOptions.density;\n      } else {\n        throw new Error('Invalid density (1 to 2400) ' + inputOptions.density);\n      }\n    }\n    // Raw pixel input\n    if (is.defined(inputOptions.raw)) {\n      if (\n        is.object(inputOptions.raw) &&\n        is.integer(inputOptions.raw.width) && is.inRange(inputOptions.raw.width, 1, this.constructor.maximum.width) &&\n        is.integer(inputOptions.raw.height) && is.inRange(inputOptions.raw.height, 1, this.constructor.maximum.height) &&\n        is.integer(inputOptions.raw.channels) && is.inRange(inputOptions.raw.channels, 1, 4)\n      ) {\n        inputDescriptor.rawWidth = inputOptions.raw.width;\n        inputDescriptor.rawHeight = inputOptions.raw.height;\n        inputDescriptor.rawChannels = inputOptions.raw.channels;\n      } else {\n        throw new Error('Expected width, height and channels for raw pixel input');\n      }\n    }\n    // Create new image\n    if (is.defined(inputOptions.create)) {\n      if (\n        is.object(inputOptions.create) &&\n        is.integer(inputOptions.create.width) && is.inRange(inputOptions.create.width, 1, this.constructor.maximum.width) &&\n        is.integer(inputOptions.create.height) && is.inRange(inputOptions.create.height, 1, this.constructor.maximum.height) &&\n        is.integer(inputOptions.create.channels) && is.inRange(inputOptions.create.channels, 3, 4) &&\n        is.defined(inputOptions.create.background)\n      ) {\n        inputDescriptor.createWidth = inputOptions.create.width;\n        inputDescriptor.createHeight = inputOptions.create.height;\n        inputDescriptor.createChannels = inputOptions.create.channels;\n        const background = color(inputOptions.create.background);\n        inputDescriptor.createBackground = [\n          background.red(),\n          background.green(),\n          background.blue(),\n          Math.round(background.alpha() * 255)\n        ];\n        delete inputDescriptor.buffer;\n      } else {\n        throw new Error('Expected width, height, channels and background to create a new input image');\n      }\n    }\n  } else if (is.defined(inputOptions)) {\n    throw new Error('Invalid input options ' + inputOptions);\n  }\n  return inputDescriptor;\n}\n\n/**\n * Handle incoming Buffer chunk on Writable Stream.\n * @private\n * @param {Buffer} chunk\n * @param {String} encoding - unused\n * @param {Function} callback\n */\nfunction _write (chunk, encoding, callback) {\n  /* istanbul ignore else */\n  if (Array.isArray(this.options.input.buffer)) {\n    /* istanbul ignore else */\n    if (is.buffer(chunk)) {\n      if (this.options.input.buffer.length === 0) {\n        const that = this;\n        this.on('finish', function () {\n          that.streamInFinished = true;\n        });\n      }\n      this.options.input.buffer.push(chunk);\n      callback();\n    } else {\n      callback(new Error('Non-Buffer data on Writable Stream'));\n    }\n  } else {\n    callback(new Error('Unexpected data on Writable Stream'));\n  }\n}\n\n/**\n * Flattens the array of chunks accumulated in input.buffer.\n * @private\n */\nfunction _flattenBufferIn () {\n  if (this._isStreamInput()) {\n    this.options.input.buffer = Buffer.concat(this.options.input.buffer);\n  }\n}\n\n/**\n * Are we expecting Stream-based input?\n * @private\n * @returns {Boolean}\n */\nfunction _isStreamInput () {\n  return Array.isArray(this.options.input.buffer);\n}\n\n/**\n * Take a \"snapshot\" of the Sharp instance, returning a new instance.\n * Cloned instances inherit the input of their parent instance.\n * This allows multiple output Streams and therefore multiple processing pipelines to share a single input Stream.\n *\n * @example\n * const pipeline = sharp().rotate();\n * pipeline.clone().resize(800, 600).pipe(firstWritableStream);\n * pipeline.clone().extract({ left: 20, top: 20, width: 100, height: 100 }).pipe(secondWritableStream);\n * readableStream.pipe(pipeline);\n * // firstWritableStream receives auto-rotated, resized readableStream\n * // secondWritableStream receives auto-rotated, extracted region of readableStream\n *\n * @returns {Sharp}\n */\nfunction clone () {\n  const that = this;\n  // Clone existing options\n  const clone = this.constructor.call();\n  util._extend(clone.options, this.options);\n  // Pass 'finish' event to clone for Stream-based input\n  this.on('finish', function () {\n    // Clone inherits input data\n    that._flattenBufferIn();\n    clone.options.bufferIn = that.options.bufferIn;\n    clone.emit('finish');\n  });\n  return clone;\n}\n\n/**\n * Fast access to image metadata without decoding any compressed image data.\n * A Promises/A+ promise is returned when `callback` is not provided.\n *\n * - `format`: Name of decoder used to decompress image data e.g. `jpeg`, `png`, `webp`, `gif`, `svg`\n * - `width`: Number of pixels wide\n * - `height`: Number of pixels high\n * - `space`: Name of colour space interpretation e.g. `srgb`, `rgb`, `cmyk`, `lab`, `b-w` [...](https://github.com/jcupitt/libvips/blob/master/libvips/iofuncs/enumtypes.c#L568)\n * - `channels`: Number of bands e.g. `3` for sRGB, `4` for CMYK\n * - `density`: Number of pixels per inch (DPI), if present\n * - `hasProfile`: Boolean indicating the presence of an embedded ICC profile\n * - `hasAlpha`: Boolean indicating the presence of an alpha transparency channel\n * - `orientation`: Number value of the EXIF Orientation header, if present\n * - `exif`: Buffer containing raw EXIF data, if present\n * - `icc`: Buffer containing raw [ICC](https://www.npmjs.com/package/icc) profile data, if present\n *\n * @example\n * const image = sharp(inputJpg);\n * image\n *   .metadata()\n *   .then(function(metadata) {\n *     return image\n *       .resize(Math.round(metadata.width / 2))\n *       .webp()\n *       .toBuffer();\n *   })\n *   .then(function(data) {\n *     // data contains a WebP image half the width and height of the original JPEG\n *   });\n *\n * @param {Function} [callback] - called with the arguments `(err, metadata)`\n * @returns {Promise<Object>|Sharp}\n */\nfunction metadata (callback) {\n  const that = this;\n  if (is.fn(callback)) {\n    if (this._isStreamInput()) {\n      this.on('finish', function () {\n        that._flattenBufferIn();\n        sharp.metadata(that.options, callback);\n      });\n    } else {\n      sharp.metadata(this.options, callback);\n    }\n    return this;\n  } else {\n    if (this._isStreamInput()) {\n      return new Promise(function (resolve, reject) {\n        that.on('finish', function () {\n          that._flattenBufferIn();\n          sharp.metadata(that.options, function (err, metadata) {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(metadata);\n            }\n          });\n        });\n      });\n    } else {\n      return new Promise(function (resolve, reject) {\n        sharp.metadata(that.options, function (err, metadata) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(metadata);\n          }\n        });\n      });\n    }\n  }\n}\n\n/**\n * Do not process input images where the number of pixels (width * height) exceeds this limit.\n * Assumes image dimensions contained in the input metadata can be trusted.\n * The default limit is 268402689 (0x3FFF * 0x3FFF) pixels.\n * @param {(Number|Boolean)} limit - an integral Number of pixels, zero or false to remove limit, true to use default limit.\n * @returns {Sharp}\n * @throws {Error} Invalid limit\n*/\nfunction limitInputPixels (limit) {\n  // if we pass in false we represent the integer as 0 to disable\n  if (limit === false) {\n    limit = 0;\n  } else if (limit === true) {\n    limit = this.constructor.maximum.pixels;\n  }\n  if (is.integer(limit) && limit >= 0) {\n    this.options.limitInputPixels = limit;\n  } else {\n    throw new Error('Invalid pixel limit (0 to ' + this.constructor.maximum.pixels + ') ' + limit);\n  }\n  return this;\n}\n\n/**\n * An advanced setting that switches the libvips access method to `VIPS_ACCESS_SEQUENTIAL`.\n * This will reduce memory usage and can improve performance on some systems.\n * @param {Boolean} [sequentialRead=true]\n * @returns {Sharp}\n */\nfunction sequentialRead (sequentialRead) {\n  this.options.sequentialRead = is.bool(sequentialRead) ? sequentialRead : true;\n  return this;\n}\n\n/**\n * Decorate the Sharp prototype with input-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  [\n    // Private\n    _createInputDescriptor,\n    _write,\n    _flattenBufferIn,\n    _isStreamInput,\n    // Public\n    clone,\n    metadata,\n    limitInputPixels,\n    sequentialRead\n  ].forEach(function (f) {\n    Sharp.prototype[f.name] = f;\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-sharp/sharp/lib/is.js":"'use strict';\n\n/**\n * Is this value defined and not null?\n * @private\n */\nconst defined = function (val) {\n  return typeof val !== 'undefined' && val !== null;\n};\n\n/**\n * Is this value an object?\n * @private\n */\nconst object = function (val) {\n  return typeof val === 'object';\n};\n\n/**\n * Is this value a function?\n * @private\n */\nconst fn = function (val) {\n  return typeof val === 'function';\n};\n\n/**\n * Is this value a boolean?\n * @private\n */\nconst bool = function (val) {\n  return typeof val === 'boolean';\n};\n\n/**\n * Is this value a Buffer object?\n * @private\n */\nconst buffer = function (val) {\n  return object(val) && val instanceof Buffer;\n};\n\n/**\n * Is this value a non-empty string?\n * @private\n */\nconst string = function (val) {\n  return typeof val === 'string' && val.length > 0;\n};\n\n/**\n * Is this value a real number?\n * @private\n */\nconst number = function (val) {\n  return typeof val === 'number' && !Number.isNaN(val);\n};\n\n/**\n * Is this value an integer?\n * @private\n */\nconst integer = function (val) {\n  return number(val) && val % 1 === 0;\n};\n\n/**\n * Is this value within an inclusive given range?\n * @private\n */\nconst inRange = function (val, min, max) {\n  return val >= min && val <= max;\n};\n\n/**\n * Is this value within the elements of an array?\n * @private\n */\nconst inArray = function (val, list) {\n  return list.indexOf(val) !== -1;\n};\n\n/**\n * Create an Error with a message relating to an invalid parameter.\n *\n * @param {String} name - parameter name.\n * @param {String} expected - description of the type/value/range expected.\n * @param {*} actual - the value received.\n * @returns {Error} Containing the formatted message.\n * @private\n */\nconst invalidParameterError = function (name, expected, actual) {\n  return new Error(\n    `Expected ${expected} for ${name} but received ${actual} of type ${typeof actual}`\n  );\n};\n\nmodule.exports = {\n  defined: defined,\n  object: object,\n  fn: fn,\n  bool: bool,\n  buffer: buffer,\n  string: string,\n  number: number,\n  integer: integer,\n  inRange: inRange,\n  inArray: inArray,\n  invalidParameterError: invalidParameterError\n};\n","/home/travis/build/npmtest/node-npmtest-sharp/sharp/lib/resize.js":"'use strict';\n\nconst is = require('./is');\n\n/**\n * Weighting to apply to image crop.\n * @member\n * @private\n */\nconst gravity = {\n  center: 0,\n  centre: 0,\n  north: 1,\n  east: 2,\n  south: 3,\n  west: 4,\n  northeast: 5,\n  southeast: 6,\n  southwest: 7,\n  northwest: 8\n};\n\n/**\n * Strategies for automagic crop behaviour.\n * @member\n * @private\n */\nconst strategy = {\n  entropy: 16,\n  attention: 17\n};\n\n/**\n * Reduction kernels.\n * @member\n * @private\n */\nconst kernel = {\n  nearest: 'nearest',\n  cubic: 'cubic',\n  lanczos2: 'lanczos2',\n  lanczos3: 'lanczos3'\n};\n\n/**\n * Enlargement interpolators.\n * @member\n * @private\n */\nconst interpolator = {\n  nearest: 'nearest',\n  bilinear: 'bilinear',\n  bicubic: 'bicubic',\n  nohalo: 'nohalo',\n  lbb: 'lbb',\n  locallyBoundedBicubic: 'lbb',\n  vsqbs: 'vsqbs',\n  vertexSplitQuadraticBasisSpline: 'vsqbs'\n};\n\n/**\n * Resize image to `width` x `height`.\n * By default, the resized image is centre cropped to the exact size specified.\n *\n * Possible reduction kernels are:\n * - `nearest`: Use [nearest neighbour interpolation](http://en.wikipedia.org/wiki/Nearest-neighbor_interpolation).\n * - `cubic`: Use a [Catmull-Rom spline](https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline).\n * - `lanczos2`: Use a [Lanczos kernel](https://en.wikipedia.org/wiki/Lanczos_resampling#Lanczos_kernel) with `a=2`.\n * - `lanczos3`: Use a Lanczos kernel with `a=3` (the default).\n *\n * Possible enlargement interpolators are:\n * - `nearest`: Use [nearest neighbour interpolation](http://en.wikipedia.org/wiki/Nearest-neighbor_interpolation).\n * - `bilinear`: Use [bilinear interpolation](http://en.wikipedia.org/wiki/Bilinear_interpolation), faster than bicubic but with less smooth results.\n * - `vertexSplitQuadraticBasisSpline`: Use the smoother [VSQBS interpolation](https://github.com/jcupitt/libvips/blob/master/libvips/resample/vsqbs.cpp#L48) to prevent \"staircasing\" when enlarging.\n * - `bicubic`: Use [bicubic interpolation](http://en.wikipedia.org/wiki/Bicubic_interpolation) (the default).\n * - `locallyBoundedBicubic`: Use [LBB interpolation](https://github.com/jcupitt/libvips/blob/master/libvips/resample/lbb.cpp#L100), which prevents some \"[acutance](http://en.wikipedia.org/wiki/Acutance)\" but typically reduces performance by a factor of 2.\n * - `nohalo`: Use [Nohalo interpolation](http://eprints.soton.ac.uk/268086/), which prevents acutance but typically reduces performance by a factor of 3.\n *\n * @example\n * sharp(inputBuffer)\n *   .resize(200, 300, {\n *     kernel: sharp.kernel.lanczos2,\n *     interpolator: sharp.interpolator.nohalo\n *   })\n *   .background('white')\n *   .embed()\n *   .toFile('output.tiff')\n *   .then(function() {\n *     // output.tiff is a 200 pixels wide and 300 pixels high image\n *     // containing a lanczos2/nohalo scaled version, embedded on a white canvas,\n *     // of the image data in inputBuffer\n *   });\n *\n * @param {Number} [width] - pixels wide the resultant image should be, between 1 and 16383 (0x3FFF). Use `null` or `undefined` to auto-scale the width to match the height.\n * @param {Number} [height] - pixels high the resultant image should be, between 1 and 16383. Use `null` or `undefined` to auto-scale the height to match the width.\n * @param {Object} [options]\n * @param {String} [options.kernel='lanczos3'] - the kernel to use for image reduction.\n * @param {String} [options.interpolator='bicubic'] - the interpolator to use for image enlargement.\n * @param {Boolean} [options.centreSampling=false] - use *magick centre sampling convention instead of corner sampling.\n * @param {Boolean} [options.centerSampling=false] - alternative spelling of centreSampling.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction resize (width, height, options) {\n  if (is.defined(width)) {\n    if (is.integer(width) && is.inRange(width, 1, this.constructor.maximum.width)) {\n      this.options.width = width;\n    } else {\n      throw is.invalidParameterError('width', `integer between 1 and ${this.constructor.maximum.width}`, width);\n    }\n  } else {\n    this.options.width = -1;\n  }\n  if (is.defined(height)) {\n    if (is.integer(height) && is.inRange(height, 1, this.constructor.maximum.height)) {\n      this.options.height = height;\n    } else {\n      throw is.invalidParameterError('height', `integer between 1 and ${this.constructor.maximum.height}`, height);\n    }\n  } else {\n    this.options.height = -1;\n  }\n  if (is.object(options)) {\n    // Kernel\n    if (is.defined(options.kernel)) {\n      if (is.string(kernel[options.kernel])) {\n        this.options.kernel = kernel[options.kernel];\n      } else {\n        throw is.invalidParameterError('kernel', 'valid kernel name', options.kernel);\n      }\n    }\n    // Interpolator\n    if (is.defined(options.interpolator)) {\n      if (is.string(interpolator[options.interpolator])) {\n        this.options.interpolator = interpolator[options.interpolator];\n      } else {\n        throw is.invalidParameterError('interpolator', 'valid interpolator name', options.interpolator);\n      }\n    }\n    // Centre sampling\n    options.centreSampling = is.bool(options.centerSampling) ? options.centerSampling : options.centreSampling;\n    if (is.defined(options.centreSampling)) {\n      this._setBooleanOption('centreSampling', options.centreSampling);\n    }\n  }\n  return this;\n}\n\n/**\n * Crop the resized image to the exact size specified, the default behaviour.\n *\n * Possible attributes of the optional `sharp.gravity` are `north`, `northeast`, `east`, `southeast`, `south`,\n * `southwest`, `west`, `northwest`, `center` and `centre`.\n *\n * The experimental strategy-based approach resizes so one dimension is at its target length\n * then repeatedly ranks edge regions, discarding the edge with the lowest score based on the selected strategy.\n * - `entropy`: focus on the region with the highest [Shannon entropy](https://en.wikipedia.org/wiki/Entropy_%28information_theory%29).\n * - `attention`: focus on the region with the highest luminance frequency, colour saturation and presence of skin tones.\n *\n * @example\n * const transformer = sharp()\n *   .resize(200, 200)\n *   .crop(sharp.strategy.entropy)\n *   .on('error', function(err) {\n *     console.log(err);\n *   });\n * // Read image data from readableStream\n * // Write 200px square auto-cropped image data to writableStream\n * readableStream.pipe(transformer).pipe(writableStream);\n *\n * @param {String} [crop='centre'] - A member of `sharp.gravity` to crop to an edge/corner or `sharp.strategy` to crop dynamically.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction crop (crop) {\n  this.options.canvas = 'crop';\n  if (!is.defined(crop)) {\n    // Default\n    this.options.crop = gravity.center;\n  } else if (is.integer(crop) && is.inRange(crop, 0, 8)) {\n    // Gravity (numeric)\n    this.options.crop = crop;\n  } else if (is.string(crop) && is.integer(gravity[crop])) {\n    // Gravity (string)\n    this.options.crop = gravity[crop];\n  } else if (is.integer(crop) && crop >= strategy.entropy) {\n    // Strategy\n    this.options.crop = crop;\n  } else if (is.string(crop) && is.integer(strategy[crop])) {\n    // Strategy (string)\n    this.options.crop = strategy[crop];\n  } else {\n    throw is.invalidParameterError('crop', 'valid crop id/name/strategy', crop);\n  }\n  return this;\n}\n\n/**\n * Preserving aspect ratio, resize the image to the maximum `width` or `height` specified\n * then embed on a background of the exact `width` and `height` specified.\n *\n * If the background contains an alpha value then WebP and PNG format output images will\n * contain an alpha channel, even when the input image does not.\n *\n * @example\n * sharp('input.gif')\n *   .resize(200, 300)\n *   .background({r: 0, g: 0, b: 0, alpha: 0})\n *   .embed()\n *   .toFormat(sharp.format.webp)\n *   .toBuffer(function(err, outputBuffer) {\n *     if (err) {\n *       throw err;\n *     }\n *     // outputBuffer contains WebP image data of a 200 pixels wide and 300 pixels high\n *     // containing a scaled version, embedded on a transparent canvas, of input.gif\n *   });\n *\n * @returns {Sharp}\n */\nfunction embed () {\n  this.options.canvas = 'embed';\n  return this;\n}\n\n/**\n * Preserving aspect ratio, resize the image to be as large as possible\n * while ensuring its dimensions are less than or equal to the `width` and `height` specified.\n *\n * Both `width` and `height` must be provided via `resize` otherwise the behaviour will default to `crop`.\n *\n * @example\n * sharp(inputBuffer)\n *   .resize(200, 200)\n *   .max()\n *   .toFormat('jpeg')\n *   .toBuffer()\n *   .then(function(outputBuffer) {\n *     // outputBuffer contains JPEG image data no wider than 200 pixels and no higher\n *     // than 200 pixels regardless of the inputBuffer image dimensions\n *   });\n *\n * @returns {Sharp}\n */\nfunction max () {\n  this.options.canvas = 'max';\n  return this;\n}\n\n/**\n * Preserving aspect ratio, resize the image to be as small as possible\n * while ensuring its dimensions are greater than or equal to the `width` and `height` specified.\n *\n * Both `width` and `height` must be provided via `resize` otherwise the behaviour will default to `crop`.\n *\n * @returns {Sharp}\n */\nfunction min () {\n  this.options.canvas = 'min';\n  return this;\n}\n\n/**\n * Ignoring the aspect ratio of the input, stretch the image to\n * the exact `width` and/or `height` provided via `resize`.\n * @returns {Sharp}\n */\nfunction ignoreAspectRatio () {\n  this.options.canvas = 'ignore_aspect';\n  return this;\n}\n\n/**\n * Do not enlarge the output image if the input image width *or* height are already less than the required dimensions.\n * This is equivalent to GraphicsMagick's `>` geometry option:\n * \"*change the dimensions of the image only if its width or height exceeds the geometry specification*\".\n * @param {Boolean} [withoutEnlargement=true]\n * @returns {Sharp}\n*/\nfunction withoutEnlargement (withoutEnlargement) {\n  this.options.withoutEnlargement = is.bool(withoutEnlargement) ? withoutEnlargement : true;\n  return this;\n}\n\n/**\n * Decorate the Sharp prototype with resize-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  [\n    resize,\n    crop,\n    embed,\n    max,\n    min,\n    ignoreAspectRatio,\n    withoutEnlargement\n  ].forEach(function (f) {\n    Sharp.prototype[f.name] = f;\n  });\n  // Class attributes\n  Sharp.gravity = gravity;\n  Sharp.strategy = strategy;\n  Sharp.kernel = kernel;\n  Sharp.interpolator = interpolator;\n};\n","/home/travis/build/npmtest/node-npmtest-sharp/sharp/lib/composite.js":"'use strict';\n\nconst is = require('./is');\n\n/**\n * Overlay (composite) an image over the processed (resized, extracted etc.) image.\n *\n * The overlay image must be the same size or smaller than the processed image.\n * If both `top` and `left` options are provided, they take precedence over `gravity`.\n *\n * @example\n * sharp('input.png')\n *   .rotate(180)\n *   .resize(300)\n *   .flatten()\n *   .background('#ff6600')\n *   .overlayWith('overlay.png', { gravity: sharp.gravity.southeast } )\n *   .sharpen()\n *   .withMetadata()\n *   .quality(90)\n *   .webp()\n *   .toBuffer()\n *   .then(function(outputBuffer) {\n *     // outputBuffer contains upside down, 300px wide, alpha channel flattened\n *     // onto orange background, composited with overlay.png with SE gravity,\n *     // sharpened, with metadata, 90% quality WebP image data. Phew!\n *   });\n *\n * @param {(Buffer|String)} overlay - Buffer containing image data or String containing the path to an image file.\n * @param {Object} [options]\n * @param {String} [options.gravity='centre'] - gravity at which to place the overlay.\n * @param {Number} [options.top] - the pixel offset from the top edge.\n * @param {Number} [options.left] - the pixel offset from the left edge.\n * @param {Boolean} [options.tile=false] - set to true to repeat the overlay image across the entire image with the given `gravity`.\n * @param {Boolean} [options.cutout=false] - set to true to apply only the alpha channel of the overlay image to the input image, giving the appearance of one image being cut out of another.\n * @param {Number} [options.density=72] - integral number representing the DPI for vector overlay image.\n * @param {Object} [options.raw] - describes overlay when using raw pixel data.\n * @param {Number} [options.raw.width]\n * @param {Number} [options.raw.height]\n * @param {Number} [options.raw.channels]\n * @param {Object} [options.create] - describes a blank overlay to be created.\n * @param {Number} [options.create.width]\n * @param {Number} [options.create.height]\n * @param {Number} [options.create.channels] - 3-4\n * @param {String|Object} [options.create.background] - parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction overlayWith (overlay, options) {\n  this.options.overlay = this._createInputDescriptor(overlay, options, {\n    allowStream: false\n  });\n  if (is.object(options)) {\n    if (is.defined(options.tile)) {\n      if (is.bool(options.tile)) {\n        this.options.overlayTile = options.tile;\n      } else {\n        throw new Error('Invalid overlay tile ' + options.tile);\n      }\n    }\n    if (is.defined(options.cutout)) {\n      if (is.bool(options.cutout)) {\n        this.options.overlayCutout = options.cutout;\n      } else {\n        throw new Error('Invalid overlay cutout ' + options.cutout);\n      }\n    }\n    if (is.defined(options.left) || is.defined(options.top)) {\n      if (\n        is.integer(options.left) && is.inRange(options.left, 0, this.constructor.maximum.width) &&\n        is.integer(options.top) && is.inRange(options.top, 0, this.constructor.maximum.height)\n      ) {\n        this.options.overlayXOffset = options.left;\n        this.options.overlayYOffset = options.top;\n      } else {\n        throw new Error('Invalid overlay left ' + options.left + ' and/or top ' + options.top);\n      }\n    }\n    if (is.defined(options.gravity)) {\n      if (is.integer(options.gravity) && is.inRange(options.gravity, 0, 8)) {\n        this.options.overlayGravity = options.gravity;\n      } else if (is.string(options.gravity) && is.integer(this.constructor.gravity[options.gravity])) {\n        this.options.overlayGravity = this.constructor.gravity[options.gravity];\n      } else {\n        throw new Error('Unsupported overlay gravity ' + options.gravity);\n      }\n    }\n  }\n  return this;\n}\n\n/**\n * Decorate the Sharp prototype with composite-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  Sharp.prototype.overlayWith = overlayWith;\n};\n","/home/travis/build/npmtest/node-npmtest-sharp/sharp/lib/operation.js":"'use strict';\n\nconst is = require('./is');\n\n/**\n * Rotate the output image by either an explicit angle\n * or auto-orient based on the EXIF `Orientation` tag.\n *\n * Use this method without angle to determine the angle from EXIF data.\n * Mirroring is supported and may infer the use of a flip operation.\n *\n * The use of `rotate` implies the removal of the EXIF `Orientation` tag, if any.\n *\n * Method order is important when both rotating and extracting regions,\n * for example `rotate(x).extract(y)` will produce a different result to `extract(y).rotate(x)`.\n *\n * @example\n * const pipeline = sharp()\n *   .rotate()\n *   .resize(null, 200)\n *   .toBuffer(function (err, outputBuffer, info) {\n *     // outputBuffer contains 200px high JPEG image data,\n *     // auto-rotated using EXIF Orientation tag\n *     // info.width and info.height contain the dimensions of the resized image\n *   });\n * readableStream.pipe(pipeline);\n *\n * @param {Number} [angle=auto] 0, 90, 180 or 270.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction rotate (angle) {\n  if (!is.defined(angle)) {\n    this.options.angle = -1;\n  } else if (is.integer(angle) && is.inArray(angle, [0, 90, 180, 270])) {\n    this.options.angle = angle;\n  } else {\n    throw new Error('Unsupported angle (0, 90, 180, 270) ' + angle);\n  }\n  return this;\n}\n\n/**\n * Extract a region of the image.\n *\n * - Use `extract` before `resize` for pre-resize extraction.\n * - Use `extract` after `resize` for post-resize extraction.\n * - Use `extract` before and after for both.\n *\n * @example\n * sharp(input)\n *   .extract({ left: left, top: top, width: width, height: height })\n *   .toFile(output, function(err) {\n *     // Extract a region of the input image, saving in the same format.\n *   });\n * @example\n * sharp(input)\n *   .extract({ left: leftOffsetPre, top: topOffsetPre, width: widthPre, height: heightPre })\n *   .resize(width, height)\n *   .extract({ left: leftOffsetPost, top: topOffsetPost, width: widthPost, height: heightPost })\n *   .toFile(output, function(err) {\n *     // Extract a region, resize, then extract from the resized image\n *   });\n *\n * @param {Object} options\n * @param {Number} options.left - zero-indexed offset from left edge\n * @param {Number} options.top - zero-indexed offset from top edge\n * @param {Number} options.width - dimension of extracted image\n * @param {Number} options.height - dimension of extracted image\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction extract (options) {\n  const suffix = this.options.width === -1 && this.options.height === -1 ? 'Pre' : 'Post';\n  ['left', 'top', 'width', 'height'].forEach(function (name) {\n    const value = options[name];\n    if (is.integer(value) && value >= 0) {\n      this.options[name + (name === 'left' || name === 'top' ? 'Offset' : '') + suffix] = value;\n    } else {\n      throw new Error('Non-integer value for ' + name + ' of ' + value);\n    }\n  }, this);\n  // Ensure existing rotation occurs before pre-resize extraction\n  if (suffix === 'Pre' && this.options.angle !== 0) {\n    this.options.rotateBeforePreExtract = true;\n  }\n  return this;\n}\n\n/**\n * Flip the image about the vertical Y axis. This always occurs after rotation, if any.\n * The use of `flip` implies the removal of the EXIF `Orientation` tag, if any.\n * @param {Boolean} [flip=true]\n * @returns {Sharp}\n */\nfunction flip (flip) {\n  this.options.flip = is.bool(flip) ? flip : true;\n  return this;\n}\n\n/**\n * Flop the image about the horizontal X axis. This always occurs after rotation, if any.\n * The use of `flop` implies the removal of the EXIF `Orientation` tag, if any.\n * @param {Boolean} [flop=true]\n * @returns {Sharp}\n */\nfunction flop (flop) {\n  this.options.flop = is.bool(flop) ? flop : true;\n  return this;\n}\n\n/**\n * Sharpen the image.\n * When used without parameters, performs a fast, mild sharpen of the output image.\n * When a `sigma` is provided, performs a slower, more accurate sharpen of the L channel in the LAB colour space.\n * Separate control over the level of sharpening in \"flat\" and \"jagged\" areas is available.\n *\n * @param {Number} [sigma] - the sigma of the Gaussian mask, where `sigma = 1 + radius / 2`.\n * @param {Number} [flat=1.0] - the level of sharpening to apply to \"flat\" areas.\n * @param {Number} [jagged=2.0] - the level of sharpening to apply to \"jagged\" areas.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction sharpen (sigma, flat, jagged) {\n  if (!is.defined(sigma)) {\n    // No arguments: default to mild sharpen\n    this.options.sharpenSigma = -1;\n  } else if (is.bool(sigma)) {\n    // Boolean argument: apply mild sharpen?\n    this.options.sharpenSigma = sigma ? -1 : 0;\n  } else if (is.number(sigma) && is.inRange(sigma, 0.01, 10000)) {\n    // Numeric argument: specific sigma\n    this.options.sharpenSigma = sigma;\n    // Control over flat areas\n    if (is.defined(flat)) {\n      if (is.number(flat) && is.inRange(flat, 0, 10000)) {\n        this.options.sharpenFlat = flat;\n      } else {\n        throw new Error('Invalid sharpen level for flat areas (0.0 - 10000.0) ' + flat);\n      }\n    }\n    // Control over jagged areas\n    if (is.defined(jagged)) {\n      if (is.number(jagged) && is.inRange(jagged, 0, 10000)) {\n        this.options.sharpenJagged = jagged;\n      } else {\n        throw new Error('Invalid sharpen level for jagged areas (0.0 - 10000.0) ' + jagged);\n      }\n    }\n  } else {\n    throw new Error('Invalid sharpen sigma (0.01 - 10000) ' + sigma);\n  }\n  return this;\n}\n\n/**\n * Blur the image.\n * When used without parameters, performs a fast, mild blur of the output image.\n * When a `sigma` is provided, performs a slower, more accurate Gaussian blur.\n * @param {Number} [sigma] a value between 0.3 and 1000 representing the sigma of the Gaussian mask, where `sigma = 1 + radius / 2`.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction blur (sigma) {\n  if (!is.defined(sigma)) {\n    // No arguments: default to mild blur\n    this.options.blurSigma = -1;\n  } else if (is.bool(sigma)) {\n    // Boolean argument: apply mild blur?\n    this.options.blurSigma = sigma ? -1 : 0;\n  } else if (is.number(sigma) && is.inRange(sigma, 0.3, 1000)) {\n    // Numeric argument: specific sigma\n    this.options.blurSigma = sigma;\n  } else {\n    throw new Error('Invalid blur sigma (0.3 - 1000.0) ' + sigma);\n  }\n  return this;\n}\n\n/**\n * Extends/pads the edges of the image with the colour provided to the `background` method.\n * This operation will always occur after resizing and extraction, if any.\n *\n * @example\n * // Resize to 140 pixels wide, then add 10 transparent pixels\n * // to the top, left and right edges and 20 to the bottom edge\n * sharp(input)\n *   .resize(140)\n *   .background({r: 0, g: 0, b: 0, alpha: 0})\n *   .extend({top: 10, bottom: 20, left: 10, right: 10})\n *   ...\n *\n * @param {(Number|Object)} extend - single pixel count to add to all edges or an Object with per-edge counts\n * @param {Number} [extend.top]\n * @param {Number} [extend.left]\n * @param {Number} [extend.bottom]\n * @param {Number} [extend.right]\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n*/\nfunction extend (extend) {\n  if (is.integer(extend) && extend > 0) {\n    this.options.extendTop = extend;\n    this.options.extendBottom = extend;\n    this.options.extendLeft = extend;\n    this.options.extendRight = extend;\n  } else if (\n    is.object(extend) &&\n    is.integer(extend.top) && extend.top >= 0 &&\n    is.integer(extend.bottom) && extend.bottom >= 0 &&\n    is.integer(extend.left) && extend.left >= 0 &&\n    is.integer(extend.right) && extend.right >= 0\n  ) {\n    this.options.extendTop = extend.top;\n    this.options.extendBottom = extend.bottom;\n    this.options.extendLeft = extend.left;\n    this.options.extendRight = extend.right;\n  } else {\n    throw new Error('Invalid edge extension ' + extend);\n  }\n  return this;\n}\n\n/**\n * Merge alpha transparency channel, if any, with `background`.\n * @param {Boolean} [flatten=true]\n * @returns {Sharp}\n */\nfunction flatten (flatten) {\n  this.options.flatten = is.bool(flatten) ? flatten : true;\n  return this;\n}\n\n/**\n * Trim \"boring\" pixels from all edges that contain values within a percentage similarity of the top-left pixel.\n * @param {Number} [tolerance=10] value between 1 and 99 representing the percentage similarity.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction trim (tolerance) {\n  if (!is.defined(tolerance)) {\n    this.options.trimTolerance = 10;\n  } else if (is.integer(tolerance) && is.inRange(tolerance, 1, 99)) {\n    this.options.trimTolerance = tolerance;\n  } else {\n    throw new Error('Invalid trim tolerance (1 to 99) ' + tolerance);\n  }\n  return this;\n}\n\n/**\n * Apply a gamma correction by reducing the encoding (darken) pre-resize at a factor of `1/gamma`\n * then increasing the encoding (brighten) post-resize at a factor of `gamma`.\n * This can improve the perceived brightness of a resized image in non-linear colour spaces.\n * JPEG and WebP input images will not take advantage of the shrink-on-load performance optimisation\n * when applying a gamma correction.\n * @param {Number} [gamma=2.2] value between 1.0 and 3.0.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction gamma (gamma) {\n  if (!is.defined(gamma)) {\n    // Default gamma correction of 2.2 (sRGB)\n    this.options.gamma = 2.2;\n  } else if (is.number(gamma) && is.inRange(gamma, 1, 3)) {\n    this.options.gamma = gamma;\n  } else {\n    throw new Error('Invalid gamma correction (1.0 to 3.0) ' + gamma);\n  }\n  return this;\n}\n\n/**\n * Produce the \"negative\" of the image.\n * @param {Boolean} [negate=true]\n * @returns {Sharp}\n */\nfunction negate (negate) {\n  this.options.negate = is.bool(negate) ? negate : true;\n  return this;\n}\n\n/**\n * Enhance output image contrast by stretching its luminance to cover the full dynamic range.\n * @param {Boolean} [normalise=true]\n * @returns {Sharp}\n */\nfunction normalise (normalise) {\n  this.options.normalise = is.bool(normalise) ? normalise : true;\n  return this;\n}\n\n/**\n * Alternative spelling of normalise.\n * @param {Boolean} [normalize=true]\n * @returns {Sharp}\n */\nfunction normalize (normalize) {\n  return this.normalise(normalize);\n}\n\n/**\n * Convolve the image with the specified kernel.\n *\n * @example\n * sharp(input)\n *   .convolve({\n *     width: 3,\n *     height: 3,\n *     kernel: [-1, 0, 1, -2, 0, 2, -1, 0, 1]\n *   })\n *   .raw()\n *   .toBuffer(function(err, data, info) {\n *     // data contains the raw pixel data representing the convolution\n *     // of the input image with the horizontal Sobel operator\n *   });\n *\n * @param {Object} kernel\n * @param {Number} kernel.width - width of the kernel in pixels.\n * @param {Number} kernel.height - width of the kernel in pixels.\n * @param {Array<Number>} kernel.kernel - Array of length `width*height` containing the kernel values.\n * @param {Number} [kernel.scale=sum] - the scale of the kernel in pixels.\n * @param {Number} [kernel.offset=0] - the offset of the kernel in pixels.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction convolve (kernel) {\n  if (!is.object(kernel) || !Array.isArray(kernel.kernel) ||\n      !is.integer(kernel.width) || !is.integer(kernel.height) ||\n      !is.inRange(kernel.width, 3, 1001) || !is.inRange(kernel.height, 3, 1001) ||\n      kernel.height * kernel.width !== kernel.kernel.length\n     ) {\n    // must pass in a kernel\n    throw new Error('Invalid convolution kernel');\n  }\n  // Default scale is sum of kernel values\n  if (!is.integer(kernel.scale)) {\n    kernel.scale = kernel.kernel.reduce(function (a, b) {\n      return a + b;\n    }, 0);\n  }\n  // Clip scale to a minimum value of 1\n  if (kernel.scale < 1) {\n    kernel.scale = 1;\n  }\n  if (!is.integer(kernel.offset)) {\n    kernel.offset = 0;\n  }\n  this.options.convKernel = kernel;\n  return this;\n}\n\n/**\n * Any pixel value greather than or equal to the threshold value will be set to 255, otherwise it will be set to 0.\n * @param {Number} [threshold=128] - a value in the range 0-255 representing the level at which the threshold will be applied.\n * @param {Object} [options]\n * @param {Boolean} [options.greyscale=true] - convert to single channel greyscale.\n * @param {Boolean} [options.grayscale=true] - alternative spelling for greyscale.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction threshold (threshold, options) {\n  if (!is.defined(threshold)) {\n    this.options.threshold = 128;\n  } else if (is.bool(threshold)) {\n    this.options.threshold = threshold ? 128 : 0;\n  } else if (is.integer(threshold) && is.inRange(threshold, 0, 255)) {\n    this.options.threshold = threshold;\n  } else {\n    throw new Error('Invalid threshold (0 to 255) ' + threshold);\n  }\n  if (!is.object(options) || options.greyscale === true || options.grayscale === true) {\n    this.options.thresholdGrayscale = true;\n  } else {\n    this.options.thresholdGrayscale = false;\n  }\n  return this;\n}\n\n/**\n * Perform a bitwise boolean operation with operand image.\n *\n * This operation creates an output image where each pixel is the result of\n * the selected bitwise boolean `operation` between the corresponding pixels of the input images.\n *\n * @param {Buffer|String} operand - Buffer containing image data or String containing the path to an image file.\n * @param {String} operator - one of `and`, `or` or `eor` to perform that bitwise operation, like the C logic operators `&`, `|` and `^` respectively.\n * @param {Object} [options]\n * @param {Object} [options.raw] - describes operand when using raw pixel data.\n * @param {Number} [options.raw.width]\n * @param {Number} [options.raw.height]\n * @param {Number} [options.raw.channels]\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction boolean (operand, operator, options) {\n  this.options.boolean = this._createInputDescriptor(operand, options);\n  if (is.string(operator) && is.inArray(operator, ['and', 'or', 'eor'])) {\n    this.options.booleanOp = operator;\n  } else {\n    throw new Error('Invalid boolean operator ' + operator);\n  }\n  return this;\n}\n\n/**\n * Decorate the Sharp prototype with operation-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  [\n    rotate,\n    extract,\n    flip,\n    flop,\n    sharpen,\n    blur,\n    extend,\n    flatten,\n    trim,\n    gamma,\n    negate,\n    normalise,\n    normalize,\n    convolve,\n    threshold,\n    boolean\n  ].forEach(function (f) {\n    Sharp.prototype[f.name] = f;\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-sharp/sharp/lib/colour.js":"'use strict';\n\nconst color = require('color');\nconst is = require('./is');\n\n/**\n * Colourspaces.\n * @private\n */\nconst colourspace = {\n  multiband: 'multiband',\n  'b-w': 'b-w',\n  bw: 'b-w',\n  cmyk: 'cmyk',\n  srgb: 'srgb'\n};\n\n/**\n * Set the background for the `embed`, `flatten` and `extend` operations.\n * The default background is `{r: 0, g: 0, b: 0, alpha: 1}`, black without transparency.\n *\n * Delegates to the _color_ module, which can throw an Error\n * but is liberal in what it accepts, clipping values to sensible min/max.\n * The alpha value is a float between `0` (transparent) and `1` (opaque).\n *\n * @param {String|Object} rgba - parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.\n * @returns {Sharp}\n * @throws {Error} Invalid parameter\n */\nfunction background (rgba) {\n  const colour = color(rgba);\n  this.options.background = [\n    colour.red(),\n    colour.green(),\n    colour.blue(),\n    Math.round(colour.alpha() * 255)\n  ];\n  return this;\n}\n\n/**\n * Convert to 8-bit greyscale; 256 shades of grey.\n * This is a linear operation. If the input image is in a non-linear colour space such as sRGB, use `gamma()` with `greyscale()` for the best results.\n * By default the output image will be web-friendly sRGB and contain three (identical) color channels.\n * This may be overridden by other sharp operations such as `toColourspace('b-w')`,\n * which will produce an output image containing one color channel.\n * An alpha channel may be present, and will be unchanged by the operation.\n * @param {Boolean} [greyscale=true]\n * @returns {Sharp}\n */\nfunction greyscale (greyscale) {\n  this.options.greyscale = is.bool(greyscale) ? greyscale : true;\n  return this;\n}\n\n/**\n * Alternative spelling of `greyscale`.\n * @param {Boolean} [grayscale=true]\n * @returns {Sharp}\n */\nfunction grayscale (grayscale) {\n  return this.greyscale(grayscale);\n}\n\n/**\n * Set the output colourspace.\n * By default output image will be web-friendly sRGB, with additional channels interpreted as alpha channels.\n * @param {String} [colourspace] - output colourspace e.g. `srgb`, `rgb`, `cmyk`, `lab`, `b-w` [...](https://github.com/jcupitt/libvips/blob/master/libvips/iofuncs/enumtypes.c#L568)\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction toColourspace (colourspace) {\n  if (!is.string(colourspace)) {\n    throw new Error('Invalid output colourspace ' + colourspace);\n  }\n  this.options.colourspace = colourspace;\n  return this;\n}\n\n/**\n * Alternative spelling of `toColourspace`.\n * @param {String} [colorspace] - output colorspace.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction toColorspace (colorspace) {\n  return this.toColourspace(colorspace);\n}\n\n/**\n * Decorate the Sharp prototype with colour-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  // Public instance functions\n  [\n    background,\n    greyscale,\n    grayscale,\n    toColourspace,\n    toColorspace\n  ].forEach(function (f) {\n    Sharp.prototype[f.name] = f;\n  });\n  // Class attributes\n  Sharp.colourspace = colourspace;\n  Sharp.colorspace = colourspace;\n};\n","/home/travis/build/npmtest/node-npmtest-sharp/sharp/lib/channel.js":"'use strict';\n\nconst is = require('./is');\n\n/**\n * Boolean operations for bandbool.\n * @private\n */\nconst bool = {\n  and: 'and',\n  or: 'or',\n  eor: 'eor'\n};\n\n/**\n * Extract a single channel from a multi-channel image.\n *\n * @example\n * sharp(input)\n *   .extractChannel('green')\n *   .toFile('input_green.jpg', function(err, info) {\n *     // info.channels === 1\n *     // input_green.jpg contains the green channel of the input image\n *    });\n *\n * @param {Number|String} channel - zero-indexed band number to extract, or `red`, `green` or `blue` as alternative to `0`, `1` or `2` respectively.\n * @returns {Sharp}\n * @throws {Error} Invalid channel\n */\nfunction extractChannel (channel) {\n  if (channel === 'red') {\n    channel = 0;\n  } else if (channel === 'green') {\n    channel = 1;\n  } else if (channel === 'blue') {\n    channel = 2;\n  }\n  if (is.integer(channel) && is.inRange(channel, 0, 4)) {\n    this.options.extractChannel = channel;\n  } else {\n    throw new Error('Cannot extract invalid channel ' + channel);\n  }\n  return this;\n}\n\n/**\n * Join one or more channels to the image.\n * The meaning of the added channels depends on the output colourspace, set with `toColourspace()`.\n * By default the output image will be web-friendly sRGB, with additional channels interpreted as alpha channels.\n * Channel ordering follows vips convention:\n * - sRGB: 0: Red, 1: Green, 2: Blue, 3: Alpha.\n * - CMYK: 0: Magenta, 1: Cyan, 2: Yellow, 3: Black, 4: Alpha.\n *\n * Buffers may be any of the image formats supported by sharp: JPEG, PNG, WebP, GIF, SVG, TIFF or raw pixel image data.\n * For raw pixel input, the `options` object should contain a `raw` attribute, which follows the format of the attribute of the same name in the `sharp()` constructor.\n *\n * @param {Array<String|Buffer>|String|Buffer} images - one or more images (file paths, Buffers).\n * @param {Object} options - image options, see `sharp()` constructor.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction joinChannel (images, options) {\n  if (Array.isArray(images)) {\n    images.forEach(function (image) {\n      this.options.joinChannelIn.push(this._createInputDescriptor(image, options));\n    }, this);\n  } else {\n    this.options.joinChannelIn.push(this._createInputDescriptor(images, options));\n  }\n  return this;\n}\n\n/**\n * Perform a bitwise boolean operation on all input image channels (bands) to produce a single channel output image.\n *\n * @example\n * sharp('3-channel-rgb-input.png')\n *   .bandbool(sharp.bool.and)\n *   .toFile('1-channel-output.png', function (err, info) {\n *     // The output will be a single channel image where each pixel `P = R & G & B`.\n *     // If `I(1,1) = [247, 170, 14] = [0b11110111, 0b10101010, 0b00001111]`\n *     // then `O(1,1) = 0b11110111 & 0b10101010 & 0b00001111 = 0b00000010 = 2`.\n *   });\n *\n * @param {String} boolOp - one of `and`, `or` or `eor` to perform that bitwise operation, like the C logic operators `&`, `|` and `^` respectively.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction bandbool (boolOp) {\n  if (is.string(boolOp) && is.inArray(boolOp, ['and', 'or', 'eor'])) {\n    this.options.bandBoolOp = boolOp;\n  } else {\n    throw new Error('Invalid bandbool operation ' + boolOp);\n  }\n  return this;\n}\n\n/**\n * Decorate the Sharp prototype with channel-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  // Public instance functions\n  [\n    extractChannel,\n    joinChannel,\n    bandbool\n  ].forEach(function (f) {\n    Sharp.prototype[f.name] = f;\n  });\n  // Class attributes\n  Sharp.bool = bool;\n};\n","/home/travis/build/npmtest/node-npmtest-sharp/sharp/lib/output.js":"'use strict';\n\nconst util = require('util');\nconst is = require('./is');\nconst sharp = require('../build/Release/sharp.node');\n\n/**\n * Write output image data to a file.\n *\n * If an explicit output format is not selected, it will be inferred from the extension,\n * with JPEG, PNG, WebP, TIFF, DZI, and libvips' V format supported.\n * Note that raw pixel data is only supported for buffer output.\n *\n * A Promises/A+ promise is returned when `callback` is not provided.\n *\n * @param {String} fileOut - the path to write the image data to.\n * @param {Function} [callback] - called on completion with two arguments `(err, info)`.\n * `info` contains the output image `format`, `size` (bytes), `width`, `height` and `channels`.\n * @returns {Promise<Object>} - when no callback is provided\n * @throws {Error} Invalid parameters\n */\nfunction toFile (fileOut, callback) {\n  if (!fileOut || fileOut.length === 0) {\n    const errOutputInvalid = new Error('Invalid output');\n    if (is.fn(callback)) {\n      callback(errOutputInvalid);\n    } else {\n      return Promise.reject(errOutputInvalid);\n    }\n  } else {\n    if (this.options.input.file === fileOut) {\n      const errOutputIsInput = new Error('Cannot use same file for input and output');\n      if (is.fn(callback)) {\n        callback(errOutputIsInput);\n      } else {\n        return Promise.reject(errOutputIsInput);\n      }\n    } else {\n      this.options.fileOut = fileOut;\n      return this._pipeline(callback);\n    }\n  }\n  return this;\n}\n\n/**\n * Write output to a Buffer.\n * JPEG, PNG, WebP, and RAW output are supported.\n * By default, the format will match the input image, except GIF and SVG input which become PNG output.\n *\n * `callback`, if present, gets three arguments `(err, data, info)` where:\n * - `err` is an error, if any.\n * - `data` is the output image data.\n * - `info` contains the output image `format`, `size` (bytes), `width`, `height` and `channels`.\n * A Promise is returned when `callback` is not provided.\n *\n * @param {Object} [options]\n * @param {Boolean} [options.resolveWithObject] Resolve the Promise with an Object containing `data` and `info` properties instead of resolving only with `data`.\n * @param {Function} [callback]\n * @returns {Promise<Buffer>} - when no callback is provided\n */\nfunction toBuffer (options, callback) {\n  if (is.object(options)) {\n    if (is.bool(options.resolveWithObject)) {\n      this.options.resolveWithObject = options.resolveWithObject;\n    }\n  }\n  return this._pipeline(is.fn(options) ? options : callback);\n}\n\n/**\n * Include all metadata (EXIF, XMP, IPTC) from the input image in the output image.\n * The default behaviour, when `withMetadata` is not used, is to strip all metadata and convert to the device-independent sRGB colour space.\n * This will also convert to and add a web-friendly sRGB ICC profile.\n * @param {Object} [withMetadata]\n * @param {Number} [withMetadata.orientation] value between 1 and 8, used to update the EXIF `Orientation` tag.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction withMetadata (withMetadata) {\n  this.options.withMetadata = is.bool(withMetadata) ? withMetadata : true;\n  if (is.object(withMetadata)) {\n    if (is.defined(withMetadata.orientation)) {\n      if (is.integer(withMetadata.orientation) && is.inRange(withMetadata.orientation, 1, 8)) {\n        this.options.withMetadataOrientation = withMetadata.orientation;\n      } else {\n        throw new Error('Invalid orientation (1 to 8) ' + withMetadata.orientation);\n      }\n    }\n  }\n  return this;\n}\n\n/**\n * Use these JPEG options for output image.\n * @param {Object} [options] - output options\n * @param {Number} [options.quality=80] - quality, integer 1-100\n * @param {Boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {String} [options.chromaSubsampling='4:2:0'] - set to '4:4:4' to prevent chroma subsampling when quality <= 90\n * @param {Boolean} [options.trellisQuantisation=false] - apply trellis quantisation, requires mozjpeg\n * @param {Boolean} [options.overshootDeringing=false] - apply overshoot deringing, requires mozjpeg\n * @param {Boolean} [options.optimiseScans=false] - optimise progressive scans, forces progressive, requires mozjpeg\n * @param {Boolean} [options.optimizeScans=false] - alternative spelling of optimiseScans\n * @param {Boolean} [options.force=true] - force JPEG output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction jpeg (options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.jpegQuality = options.quality;\n      } else {\n        throw new Error('Invalid quality (integer, 1-100) ' + options.quality);\n      }\n    }\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('jpegProgressive', options.progressive);\n    }\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.jpegChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw new Error('Invalid chromaSubsampling (4:2:0, 4:4:4) ' + options.chromaSubsampling);\n      }\n    }\n    options.trellisQuantisation = is.bool(options.trellisQuantization) ? options.trellisQuantization : options.trellisQuantisation;\n    if (is.defined(options.trellisQuantisation)) {\n      this._setBooleanOption('jpegTrellisQuantisation', options.trellisQuantisation);\n    }\n    if (is.defined(options.overshootDeringing)) {\n      this._setBooleanOption('jpegOvershootDeringing', options.overshootDeringing);\n    }\n    options.optimiseScans = is.bool(options.optimizeScans) ? options.optimizeScans : options.optimiseScans;\n    if (is.defined(options.optimiseScans)) {\n      this._setBooleanOption('jpegOptimiseScans', options.optimiseScans);\n      if (options.optimiseScans) {\n        this.options.jpegProgressive = true;\n      }\n    }\n  }\n  return this._updateFormatOut('jpeg', options);\n}\n\n/**\n * Use these PNG options for output image.\n * @param {Object} [options]\n * @param {Boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {Number} [options.compressionLevel=6] - zlib compression level\n * @param {Boolean} [options.adaptiveFiltering=true] - use adaptive row filtering\n * @param {Boolean} [options.force=true] - force PNG output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction png (options) {\n  if (is.object(options)) {\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('pngProgressive', options.progressive);\n    }\n    if (is.defined(options.compressionLevel)) {\n      if (is.integer(options.compressionLevel) && is.inRange(options.compressionLevel, 0, 9)) {\n        this.options.pngCompressionLevel = options.compressionLevel;\n      } else {\n        throw new Error('Invalid compressionLevel (integer, 0-9) ' + options.compressionLevel);\n      }\n    }\n    if (is.defined(options.adaptiveFiltering)) {\n      this._setBooleanOption('pngAdaptiveFiltering', options.adaptiveFiltering);\n    }\n  }\n  return this._updateFormatOut('png', options);\n}\n\n/**\n * Use these WebP options for output image.\n * @param {Object} [options] - output options\n * @param {Number} [options.quality=80] - quality, integer 1-100\n * @param {Number} [options.alphaQuality=100] - quality of alpha layer, integer 0-100\n * @param {Boolean} [options.lossless=false] - use lossless compression mode\n * @param {Boolean} [options.nearLossless=false] - use near_lossless compression mode\n * @param {Boolean} [options.force=true] - force WebP output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction webp (options) {\n  if (is.object(options) && is.defined(options.quality)) {\n    if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n      this.options.webpQuality = options.quality;\n    } else {\n      throw new Error('Invalid quality (integer, 1-100) ' + options.quality);\n    }\n  }\n  if (is.object(options) && is.defined(options.alphaQuality)) {\n    if (is.integer(options.alphaQuality) && is.inRange(options.alphaQuality, 1, 100)) {\n      this.options.webpAlphaQuality = options.alphaQuality;\n    } else {\n      throw new Error('Invalid webp alpha quality (integer, 1-100) ' + options.alphaQuality);\n    }\n  }\n  if (is.object(options) && is.defined(options.lossless)) {\n    this._setBooleanOption('webpLossless', options.lossless);\n  }\n  if (is.object(options) && is.defined(options.nearLossless)) {\n    this._setBooleanOption('webpNearLossless', options.nearLossless);\n  }\n  return this._updateFormatOut('webp', options);\n}\n\n/**\n * Use these TIFF options for output image.\n * @param {Object} [options] - output options\n * @param {Number} [options.quality=80] - quality, integer 1-100\n * @param {Boolean} [options.force=true] - force TIFF output, otherwise attempt to use input format\n * @param {Boolean} [options.compression='jpeg'] - compression options: lzw, deflate, jpeg\n * @param {Boolean} [options.predictor='none'] - compression predictor options: none, horizontal, float\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction tiff (options) {\n  if (is.object(options) && is.defined(options.quality)) {\n    if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n      this.options.tiffQuality = options.quality;\n    } else {\n      throw new Error('Invalid quality (integer, 1-100) ' + options.quality);\n    }\n  }\n  // compression\n  if (is.defined(options) && is.defined(options.compression)) {\n    if (is.string(options.compression) && is.inArray(options.compression, ['lzw', 'deflate', 'jpeg', 'none'])) {\n      this.options.tiffCompression = options.compression;\n    } else {\n      const message = `Invalid compression option \"${options.compression}\". Should be one of: lzw, deflate, jpeg, none`;\n      throw new Error(message);\n    }\n  }\n  // predictor\n  if (is.defined(options) && is.defined(options.predictor)) {\n    if (is.string(options.predictor) && is.inArray(options.predictor, ['none', 'horizontal', 'float'])) {\n      this.options.tiffPredictor = options.predictor;\n    } else {\n      const message = `Invalid predictor option \"${options.predictor}\". Should be one of: none, horizontal, float`;\n      throw new Error(message);\n    }\n  }\n  return this._updateFormatOut('tiff', options);\n}\n\n/**\n * Force output to be raw, uncompressed uint8 pixel data.\n * @returns {Sharp}\n */\nfunction raw () {\n  return this._updateFormatOut('raw');\n}\n\n/**\n * Force output to a given format.\n * @param {(String|Object)} format - as a String or an Object with an 'id' attribute\n * @param {Object} options - output options\n * @returns {Sharp}\n * @throws {Error} unsupported format or options\n */\nfunction toFormat (format, options) {\n  if (is.object(format) && is.string(format.id)) {\n    format = format.id;\n  }\n  if (!is.inArray(format, ['jpeg', 'png', 'webp', 'tiff', 'raw'])) {\n    throw new Error('Unsupported output format ' + format);\n  }\n  return this[format](options);\n}\n\n/**\n * Use tile-based deep zoom (image pyramid) output.\n * Set the format and options for tile images via the `toFormat`, `jpeg`, `png` or `webp` functions.\n * Use a `.zip` or `.szi` file extension with `toFile` to write to a compressed archive file format.\n *\n * @example\n *  sharp('input.tiff')\n *   .png()\n *   .tile({\n *     size: 512\n *   })\n *   .toFile('output.dz', function(err, info) {\n *     // output.dzi is the Deep Zoom XML definition\n *     // output_files contains 512x512 tiles grouped by zoom level\n *   });\n *\n * @param {Object} [tile]\n * @param {Number} [tile.size=256] tile size in pixels, a value between 1 and 8192.\n * @param {Number} [tile.overlap=0] tile overlap in pixels, a value between 0 and 8192.\n * @param {String} [tile.container='fs'] tile container, with value `fs` (filesystem) or `zip` (compressed file).\n * @param {String} [tile.layout='dz'] filesystem layout, possible values are `dz`, `zoomify` or `google`.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction tile (tile) {\n  if (is.object(tile)) {\n    // Size of square tiles, in pixels\n    if (is.defined(tile.size)) {\n      if (is.integer(tile.size) && is.inRange(tile.size, 1, 8192)) {\n        this.options.tileSize = tile.size;\n      } else {\n        throw new Error('Invalid tile size (1 to 8192) ' + tile.size);\n      }\n    }\n    // Overlap of tiles, in pixels\n    if (is.defined(tile.overlap)) {\n      if (is.integer(tile.overlap) && is.inRange(tile.overlap, 0, 8192)) {\n        if (tile.overlap > this.options.tileSize) {\n          throw new Error('Tile overlap ' + tile.overlap + ' cannot be larger than tile size ' + this.options.tileSize);\n        }\n        this.options.tileOverlap = tile.overlap;\n      } else {\n        throw new Error('Invalid tile overlap (0 to 8192) ' + tile.overlap);\n      }\n    }\n    // Container\n    if (is.defined(tile.container)) {\n      if (is.string(tile.container) && is.inArray(tile.container, ['fs', 'zip'])) {\n        this.options.tileContainer = tile.container;\n      } else {\n        throw new Error('Invalid tile container ' + tile.container);\n      }\n    }\n    // Layout\n    if (is.defined(tile.layout)) {\n      if (is.string(tile.layout) && is.inArray(tile.layout, ['dz', 'google', 'zoomify'])) {\n        this.options.tileLayout = tile.layout;\n      } else {\n        throw new Error('Invalid tile layout ' + tile.layout);\n      }\n    }\n  }\n  // Format\n  if (is.inArray(this.options.formatOut, ['jpeg', 'png', 'webp'])) {\n    this.options.tileFormat = this.options.formatOut;\n  } else if (this.options.formatOut !== 'input') {\n    throw new Error('Invalid tile format ' + this.options.formatOut);\n  }\n  return this._updateFormatOut('dz');\n}\n\n/**\n * Update the output format unless options.force is false,\n * in which case revert to input format.\n * @private\n * @param {String} formatOut\n * @param {Object} [options]\n * @param {Boolean} [options.force=true] - force output format, otherwise attempt to use input format\n * @returns {Sharp}\n */\nfunction _updateFormatOut (formatOut, options) {\n  this.options.formatOut = (is.object(options) && options.force === false) ? 'input' : formatOut;\n  return this;\n}\n\n/**\n * Update a Boolean attribute of the this.options Object.\n * @private\n * @param {String} key\n * @param {Boolean} val\n * @throws {Error} Invalid key\n */\nfunction _setBooleanOption (key, val) {\n  if (is.bool(val)) {\n    this.options[key] = val;\n  } else {\n    throw new Error('Invalid ' + key + ' (boolean) ' + val);\n  }\n}\n\n/**\n * Called by a WriteableStream to notify us it is ready for data.\n * @private\n */\nfunction _read () {\n  if (!this.options.streamOut) {\n    this.options.streamOut = true;\n    this._pipeline();\n  }\n}\n\n/**\n * Invoke the C++ image processing pipeline\n * Supports callback, stream and promise variants\n * @private\n */\nfunction _pipeline (callback) {\n  const that = this;\n  if (typeof callback === 'function') {\n    // output=file/buffer\n    if (this._isStreamInput()) {\n      // output=file/buffer, input=stream\n      this.on('finish', function () {\n        that._flattenBufferIn();\n        sharp.pipeline(that.options, callback);\n      });\n    } else {\n      // output=file/buffer, input=file/buffer\n      sharp.pipeline(this.options, callback);\n    }\n    return this;\n  } else if (this.options.streamOut) {\n    // output=stream\n    if (this._isStreamInput()) {\n      // output=stream, input=stream\n      if (this.streamInFinished) {\n        this._flattenBufferIn();\n        sharp.pipeline(this.options, function (err, data, info) {\n          if (err) {\n            that.emit('error', err);\n          } else {\n            that.emit('info', info);\n            that.push(data);\n          }\n          that.push(null);\n        });\n      } else {\n        this.on('finish', function () {\n          that._flattenBufferIn();\n          sharp.pipeline(that.options, function (err, data, info) {\n            if (err) {\n              that.emit('error', err);\n            } else {\n              that.emit('info', info);\n              that.push(data);\n            }\n            that.push(null);\n          });\n        });\n      }\n    } else {\n      // output=stream, input=file/buffer\n      sharp.pipeline(this.options, function (err, data, info) {\n        if (err) {\n          that.emit('error', err);\n        } else {\n          that.emit('info', info);\n          that.push(data);\n        }\n        that.push(null);\n      });\n    }\n    return this;\n  } else {\n    // output=promise\n    if (this._isStreamInput()) {\n      // output=promise, input=stream\n      return new Promise(function (resolve, reject) {\n        that.on('finish', function () {\n          that._flattenBufferIn();\n          sharp.pipeline(that.options, function (err, data, info) {\n            if (err) {\n              reject(err);\n            } else {\n              if (that.options.resolveWithObject) {\n                resolve({ data: data, info: info });\n              } else {\n                resolve(data);\n              }\n            }\n          });\n        });\n      });\n    } else {\n      // output=promise, input=file/buffer\n      return new Promise(function (resolve, reject) {\n        sharp.pipeline(that.options, function (err, data, info) {\n          if (err) {\n            reject(err);\n          } else {\n            if (that.options.resolveWithObject) {\n              resolve({ data: data, info: info });\n            } else {\n              resolve(data);\n            }\n          }\n        });\n      });\n    }\n  }\n}\n\n// Deprecated output options\n/* istanbul ignore next */\nconst quality = util.deprecate(function (quality) {\n  const formatOut = this.options.formatOut;\n  const options = { quality: quality };\n  this.jpeg(options).webp(options).tiff(options);\n  this.options.formatOut = formatOut;\n  return this;\n}, 'quality: use jpeg({ quality: ... }), webp({ quality: ... }) and/or tiff({ quality: ... }) instead');\n/* istanbul ignore next */\nconst progressive = util.deprecate(function (progressive) {\n  const formatOut = this.options.formatOut;\n  const options = { progressive: (progressive !== false) };\n  this.jpeg(options).png(options);\n  this.options.formatOut = formatOut;\n  return this;\n}, 'progressive: use jpeg({ progressive: ... }) and/or png({ progressive: ... }) instead');\n/* istanbul ignore next */\nconst compressionLevel = util.deprecate(function (compressionLevel) {\n  const formatOut = this.options.formatOut;\n  this.png({ compressionLevel: compressionLevel });\n  this.options.formatOut = formatOut;\n  return this;\n}, 'compressionLevel: use png({ compressionLevel: ... }) instead');\n/* istanbul ignore next */\nconst withoutAdaptiveFiltering = util.deprecate(function (withoutAdaptiveFiltering) {\n  const formatOut = this.options.formatOut;\n  this.png({ adaptiveFiltering: (withoutAdaptiveFiltering === false) });\n  this.options.formatOut = formatOut;\n  return this;\n}, 'withoutAdaptiveFiltering: use png({ adaptiveFiltering: ... }) instead');\n/* istanbul ignore next */\nconst withoutChromaSubsampling = util.deprecate(function (withoutChromaSubsampling) {\n  const formatOut = this.options.formatOut;\n  this.jpeg({ chromaSubsampling: (withoutChromaSubsampling === false) ? '4:2:0' : '4:4:4' });\n  this.options.formatOut = formatOut;\n  return this;\n}, 'withoutChromaSubsampling: use jpeg({ chromaSubsampling: \"4:4:4\" }) instead');\n/* istanbul ignore next */\nconst trellisQuantisation = util.deprecate(function (trellisQuantisation) {\n  const formatOut = this.options.formatOut;\n  this.jpeg({ trellisQuantisation: (trellisQuantisation !== false) });\n  this.options.formatOut = formatOut;\n  return this;\n}, 'trellisQuantisation: use jpeg({ trellisQuantisation: ... }) instead');\n/* istanbul ignore next */\nconst overshootDeringing = util.deprecate(function (overshootDeringing) {\n  const formatOut = this.options.formatOut;\n  this.jpeg({ overshootDeringing: (overshootDeringing !== false) });\n  this.options.formatOut = formatOut;\n  return this;\n}, 'overshootDeringing: use jpeg({ overshootDeringing: ... }) instead');\n/* istanbul ignore next */\nconst optimiseScans = util.deprecate(function (optimiseScans) {\n  const formatOut = this.options.formatOut;\n  this.jpeg({ optimiseScans: (optimiseScans !== false) });\n  this.options.formatOut = formatOut;\n  return this;\n}, 'optimiseScans: use jpeg({ optimiseScans: ... }) instead');\n\n/**\n * Decorate the Sharp prototype with output-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  [\n    // Public\n    toFile,\n    toBuffer,\n    withMetadata,\n    jpeg,\n    png,\n    webp,\n    tiff,\n    raw,\n    toFormat,\n    tile,\n    // Private\n    _updateFormatOut,\n    _setBooleanOption,\n    _read,\n    _pipeline\n  ].forEach(function (f) {\n    Sharp.prototype[f.name] = f;\n  });\n  // Deprecated\n  Sharp.prototype.quality = quality;\n  Sharp.prototype.progressive = progressive;\n  Sharp.prototype.compressionLevel = compressionLevel;\n  Sharp.prototype.withoutAdaptiveFiltering = withoutAdaptiveFiltering;\n  Sharp.prototype.withoutChromaSubsampling = withoutChromaSubsampling;\n  Sharp.prototype.trellisQuantisation = trellisQuantisation;\n  Sharp.prototype.trellisQuantization = trellisQuantisation;\n  Sharp.prototype.overshootDeringing = overshootDeringing;\n  Sharp.prototype.optimiseScans = optimiseScans;\n  Sharp.prototype.optimizeScans = optimiseScans;\n};\n","/home/travis/build/npmtest/node-npmtest-sharp/sharp/lib/utility.js":"'use strict';\n\nconst is = require('./is');\nconst sharp = require('../build/Release/sharp.node');\n\n/**\n * Gets, or when options are provided sets, the limits of _libvips'_ operation cache.\n * Existing entries in the cache will be trimmed after any change in limits.\n * This method always returns cache statistics,\n * useful for determining how much working memory is required for a particular task.\n *\n * @example\n * const stats = sharp.cache();\n * @example\n * sharp.cache( { items: 200 } );\n * sharp.cache( { files: 0 } );\n * sharp.cache(false);\n *\n * @param {Object|Boolean} options - Object with the following attributes, or Boolean where true uses default cache settings and false removes all caching.\n * @param {Number} [options.memory=50] - is the maximum memory in MB to use for this cache\n * @param {Number} [options.files=20] - is the maximum number of files to hold open\n * @param {Number} [options.items=100] - is the maximum number of operations to cache\n * @returns {Object}\n */\nfunction cache (options) {\n  if (is.bool(options)) {\n    if (options) {\n      // Default cache settings of 50MB, 20 files, 100 items\n      return sharp.cache(50, 20, 100);\n    } else {\n      return sharp.cache(0, 0, 0);\n    }\n  } else if (is.object(options)) {\n    return sharp.cache(options.memory, options.files, options.items);\n  } else {\n    return sharp.cache();\n  }\n}\ncache(true);\n\n/**\n * Gets, or when a concurrency is provided sets,\n * the number of threads _libvips'_ should create to process each image.\n * The default value is the number of CPU cores.\n * A value of `0` will reset to this default.\n *\n * The maximum number of images that can be processed in parallel\n * is limited by libuv's `UV_THREADPOOL_SIZE` environment variable.\n *\n * This method always returns the current concurrency.\n *\n * @example\n * const threads = sharp.concurrency(); // 4\n * sharp.concurrency(2); // 2\n * sharp.concurrency(0); // 4\n *\n * @param {Number} [concurrency]\n * @returns {Number} concurrency\n */\nfunction concurrency (concurrency) {\n  return sharp.concurrency(is.integer(concurrency) ? concurrency : null);\n}\n\n/**\n * Provides access to internal task counters.\n * - queue is the number of tasks this module has queued waiting for _libuv_ to provide a worker thread from its pool.\n * - process is the number of resize tasks currently being processed.\n *\n * @example\n * const counters = sharp.counters(); // { queue: 2, process: 4 }\n *\n * @returns {Object}\n */\nfunction counters () {\n  return sharp.counters();\n}\n\n/**\n * Get and set use of SIMD vector unit instructions.\n * Requires libvips to have been compiled with liborc support.\n *\n * Improves the performance of `resize`, `blur` and `sharpen` operations\n * by taking advantage of the SIMD vector unit of the CPU, e.g. Intel SSE and ARM NEON.\n *\n * This feature is currently off by default but future versions may reverse this.\n * Versions of liborc prior to 0.4.25 are known to segfault under heavy load.\n *\n * @example\n * const simd = sharp.simd();\n * // simd is `true` if SIMD is currently enabled\n * @example\n * const simd = sharp.simd(true);\n * // attempts to enable the use of SIMD, returning true if available\n *\n * @param {Boolean} [simd=false]\n * @returns {Boolean}\n */\nfunction simd (simd) {\n  return sharp.simd(is.bool(simd) ? simd : null);\n}\nsimd(false);\n\n/**\n * Decorate the Sharp class with utility-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  [\n    cache,\n    concurrency,\n    counters,\n    simd\n  ].forEach(function (f) {\n    Sharp[f.name] = f;\n  });\n};\n"}